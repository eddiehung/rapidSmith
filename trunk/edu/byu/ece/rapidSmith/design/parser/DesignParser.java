/*
 * Copyright (c) 2010 Brigham Young University
 * 
 * This file is part of the BYU RapidSmith Tools.
 * 
 * BYU RapidSmith Tools is free software: you may redistribute it 
 * and/or modify it under the terms of the GNU General Public License 
 * as published by the Free Software Foundation, either version 2 of 
 * the License, or (at your option) any later version.
 * 
 * BYU RapidSmith Tools is distributed in the hope that it will be 
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU 
 * General Public License for more details.
 * 
 * A copy of the GNU General Public License is included with the BYU 
 * RapidSmith Tools. It can be found at doc/gpl2.txt. You may also 
 * get a copy of the license at <http://www.gnu.org/licenses/>.
 * 
 */
/* Generated By:JavaCC: Do not edit this line. DesignParser.java */
package edu.byu.ece.rapidSmith.design.parser;

import java.util.ArrayList;
import java.util.HashMap;

import edu.byu.ece.rapidSmith.device.*;
import edu.byu.ece.rapidSmith.design.*;
import edu.byu.ece.rapidSmith.util.FileTools;
import edu.byu.ece.rapidSmith.util.StringPool;

public class DesignParser implements DesignParserConstants {
  Device dev;
  WireEnumerator we;
  Utils util = Utils.getInstance();
  Design xdlDesign = null;
  Instance currInst = null;
  Module currModule = null;
  String currModuleAnchorName = null;
  Net currNet = null;
  Pin currPin = null;
  PIP currPIP = null;
  Boolean inDesignCfg = true;
  Boolean inModuleCfg = false;
  StringPool pool = new StringPool();
  String currModuleInstanceName = null;
  ArrayList<String> portNames = null;
  ArrayList<String> portInstanceNames = null;
  ArrayList<String> portPinNames = null;
  HashMap<String,Pin> modPinMap = null;


          public void setDesign(Design design){
                    xdlDesign = design;
          }

  public Device getDevice(){
          return dev;
  }

  public WireEnumerator getWireEnumerator(){
    return we;
  }

  void processAttribute(String attribute){
          int break1, break2;
          Boolean backslash = false;
          break1 = attribute.indexOf(':');
          break2 = attribute.indexOf(':',break1+1);
          String phy_name = pool.getUnique(attribute.substring(0,break1));
          String log_name = pool.getUnique(attribute.substring(break1+1,break2));
          String cfg_value = pool.getUnique(attribute.substring(break2+1,attribute.length()));

          try{
                    if(phy_name.equals("_INST_PROP")){ // Look out, this case is nasty
                              char curr = jj_input_stream.readChar();
                while(!(curr == '\u005cn' || curr == '\u005cr' || (curr == ' ' && !backslash))){
                                        if(curr == '\u005c\u005c'){
                                                backslash = true;
                                        }
                                        else{
                                                  backslash = false;
                                        }
                                        cfg_value += curr;
                                        curr = jj_input_stream.readChar();
                              }
                    }
          }
          catch (java.io.IOException e){
                    System.out.println("IOException during parsing.");
                    System.exit(1);
          }

          if(inDesignCfg){ // If this is the design configuration
                    xdlDesign.addAttribute(phy_name,log_name,cfg_value);
          }
          else if(currModule != null && inModuleCfg){
                    currModule.addAttribute(phy_name,log_name,cfg_value);
          }
          else{ // This is an instance configuration
                    currInst.addAttribute(phy_name,log_name,cfg_value);
          }
}

// <file>            ::= <design> <statements> ;
  final public void XDL_File() throws ParseException {
    Design();
    Statements();
    jj_consume_token(0);
  }

// <design>          ::= "design" <name> <part>  <ncd_version> ";"
//                     | "design" <name> <device> <package> <speed> <ncd_version> ";"
//                     ;

// NOTE: This is different than XDL 1.6
  final public void Design() throws ParseException {
    try {
      jj_consume_token(DESIGN);
      DesignName();
      Part();
      NCDVersion();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        InstanceConfiguration();
        break;
      default:
        jj_la1[0] = jj_gen;
        ;
      }
      jj_consume_token(SEMICOLON);
    } catch (ParseException e) {
                    if(e.currentToken.toString().equals("cfg")){
                              Token tmp = null;
                              // I think the cfg string is empty, can we ignore this?
                              tmp = getNextToken();
                              tmp = getNextToken();
                              if(!tmp.image.equals(";")){
                                        // I guessed wrong, throw the exception
                                        {if (true) throw e;}
                              }
                    }
    }
  }

  final public void DesignName() throws ParseException {
                String s = getToken(1).image;
          s = s.substring(1,s.length()-1); // Remove the "quotes"
          xdlDesign.setName(pool.getUnique(s));
          if(s.equals(Design.hardMacroDesignName)){
            xdlDesign.setIsHardMacro(true);
          }
    jj_consume_token(QUOTED_STRING);
  }

  final public void Part() throws ParseException {
  String partName = pool.getUnique(getToken(1).image.replace(";",""));
          xdlDesign.setPartName(partName);
          we = xdlDesign.getWireEnumerator();
          dev = xdlDesign.getDevice();
    jj_consume_token(UNQUOTED_STRING);
  }

//<ncd_version>     ::= "v"<digits>"."<digits>
  final public void NCDVersion() throws ParseException {
          xdlDesign.setNCDVersion(pool.getUnique(getToken(1).image));
    jj_consume_token(UNQUOTED_STRING);
  }

// <statements>      ::=<statement>
//                     | <statements> <statement>
//                     ;
  final public void Statements() throws ParseException {
          inDesignCfg = false;
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NET:
      case INST:
      case MODULE:
      case INSTANCE:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      Statement();
    }
  }

// <statement>       ::= <module>
//                     | <inst>
//                     | <net>
//                     ;
  final public void Statement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MODULE:
      Module();
      break;
    case INST:
    case INSTANCE:
      Instance();
      break;
    case NET:
      Net();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// <module>          ::= <module_beg> <module_ports> <module_stmts> <module_end> ;
  final public void Module() throws ParseException {
          currModule = new Module();
          portNames = new ArrayList<String>();
  portInstanceNames = new ArrayList<String>();
  portPinNames = new ArrayList<String>();
  modPinMap = new HashMap<String,Pin>();
    ModuleBeg();
    ModulePorts();
    ModuleStatements();
    ModuleEnd();
  }

//<module_beg>      ::="module" <module_name> ";"          # no anchor specified
//                    | "module" <module_name> <anchor_name> ";"
//                    ;
  final public void ModuleBeg() throws ParseException {
    jj_consume_token(MODULE);
    ModuleName();
    AnchorName();
    jj_consume_token(COMMA);
    ModuleConfiguration();
    jj_consume_token(SEMICOLON);
  }

  final public void ModuleName() throws ParseException {
          currModule.setName(getToken(1).image.substring(1,getToken(1).image.length()-1));
    jj_consume_token(QUOTED_STRING);
  }

  final public void AnchorName() throws ParseException {
  String anchorName = getToken(1).image.substring(1,getToken(1).image.length()-1);
  currModuleAnchorName = pool.getUnique(anchorName);
    jj_consume_token(QUOTED_STRING);
  }

//<module_ports>    ::= <module_port>
//                    | <module_ports> <module_port>
  final public void ModulePorts() throws ParseException {
          inModuleCfg = false;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PORT:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      ModulePort();
    }
  }

  final public void ModulePort() throws ParseException {
    jj_consume_token(PORT);
    ModulePortName();
    ModulePortInstName();
    ModulePortInstPin();
    jj_consume_token(SEMICOLON);
  }

  final public void ModulePortName() throws ParseException {
  String portName = getToken(1).image.substring(1,getToken(1).image.length()-1);
          //currPort.setName(pool.getUnique(portName));
          portNames.add(pool.getUnique(portName));
    jj_consume_token(QUOTED_STRING);
  }

  final public void ModulePortInstName() throws ParseException {
  String instName = getToken(1).image.substring(1,getToken(1).image.length()-1);
          //currPort.setInstanceName(pool.getUnique(instName));
          portInstanceNames.add(pool.getUnique(instName));
    jj_consume_token(QUOTED_STRING);
  }

  final public void ModulePortInstPin() throws ParseException {
  String pinName = getToken(1).image.substring(1,getToken(1).image.length()-1);
          //currPort.setPinName(pool.getUnique(pinName));
          portPinNames.add(pool.getUnique(pinName));
    jj_consume_token(UNQUOTED_STRING);
  }

// <module_stmts>    ::= <module_stmt>
//                    | <module_stmts> <module_stmt>
  final public void ModuleStatements() throws ParseException {
          inModuleCfg = false;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NET:
      case INST:
      case INSTANCE:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      ModuleStatement();
    }
  }

// <module_stmt>     ::= <inst>
//                     | <net>
  final public void ModuleStatement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INST:
    case INSTANCE:
      Instance();
      break;
    case NET:
      Net();
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// <module_end>      ::= "endmodule" <module_name> ";" ;
  final public void ModuleEnd() throws ParseException {
          String s = getToken(2).image.substring(1,getToken(2).image.length()-1);
          if(!s.equals(currModule.getName())){
                    System.out.println("1=" +getToken(1).image);
                    System.out.println("2=" +getToken(2).image);
                    System.out.println("3=" +getToken(3).image);
                    System.out.println("Error: This modules name is not consistent with the endmodule token.");
                    System.out.println("BeginningModuleName=" + currModule.getName() + ", EndModuleName=" + getToken(2).image);
                    System.exit(1);
          }
                  xdlDesign.addModule(currModule);

                  for(int i=0; i<portNames.size(); i++)
                  {
                    String key = portInstanceNames.get(i) + portPinNames.get(i);
                    Port port = new Port(portNames.get(i), modPinMap.get(key));
                    currModule.getPortList().add(port);
                  }

  portNames = null;
  portInstanceNames = null;
  portPinNames = null;
  modPinMap = null;
                  currModuleAnchorName = null;
          currModule = null;
    jj_consume_token(ENDMODULE);
    jj_consume_token(QUOTED_STRING);
    jj_consume_token(SEMICOLON);
  }

//<inst>            ::= <inst_prefix> <inst_stmts> ";" ;
  final public void Instance() throws ParseException {
    InstancePrefix();
    InstanceStatement();
    jj_consume_token(SEMICOLON);
  }

//<inst_prefix>     ::= <inst_prefix_id><inst_name> <inst_type> ;
  final public void InstancePrefix() throws ParseException {
    InstancePrefixID();
    InstanceName();
    InstanceType();
    jj_consume_token(COMMA);
  }

//<inst_prefix_id>  ::= "inst"    # convenient abbreviation
//                    | "instance"
//                    ;
  final public void InstancePrefixID() throws ParseException {
        inDesignCfg = false;
        currInst = new Instance();
        if(currModule == null){
                currInst.setDesign(xdlDesign);
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INST:
      jj_consume_token(INST);
      break;
    case INSTANCE:
      jj_consume_token(INSTANCE);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<inst_name>       ::= <string> ;
  final public void InstanceName() throws ParseException {
        String s = getToken(1).image;
        s = s.substring(1,s.length()-1); // Remove the "quotes"
        currInst.setName(pool.getUnique(s));

        if(currModule == null){
            xdlDesign.addInstance(currInst);
        }
        else{
                currModule.addInstance(currInst);
            currInst.setModuleTemplate(currModule);
            if(currInst.getName().equals(currModuleAnchorName)){
                currModule.setAnchor(currInst);
            }
        }
    jj_consume_token(QUOTED_STRING);
  }

//<inst_type>       ::= <string> ;
  final public void InstanceType() throws ParseException {
         String s = getToken(1).image;
          s = s.substring(1,s.length()-1); // Remove the "quotes"
          PrimitiveType t = util.createPrimitiveType(s);
          if(t == null){
                    System.out.println("Failed parsing Instance type: \u005c"" + s + "\u005c"");
                    System.exit(1);
          }
        currInst.setType(t);
    jj_consume_token(QUOTED_STRING);
  }

// <inst_stmt>       ::= <COMMA> <inst_placement>
//                     | <COMMA> <inst_module>
//                     | <COMMA> <inst_cfg>
//                     ;
  final public void InstanceStatement() throws ParseException {
    InstancePlacement();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MODULE:
      ModuleInstance();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    InstanceConfiguration();
  }

  final public void ModuleInstance() throws ParseException {
    jj_consume_token(MODULE);
    ModuleInstanceName();
    ModuleTemplate();
    ModuleTemplateInstance();
    jj_consume_token(COMMA);
  }

  final public void ModuleInstanceName() throws ParseException {
          String s = getToken(1).image;
          s = s.substring(1,s.length()-1); // Remove the "quotes"
          //currInst.setModuleInstanceName(pool.getUnique(s));
          currModuleInstanceName = pool.getUnique(s);
    jj_consume_token(QUOTED_STRING);
  }

  final public void ModuleTemplate() throws ParseException {
          String s = getToken(1).image;
          s = s.substring(1,s.length()-1); // Remove the "quotes"
  if(currModule == null)
  {
    Module m = xdlDesign.getModule(pool.getUnique(s));
            currInst.setModuleTemplate(m);
          }
    jj_consume_token(QUOTED_STRING);
  }

  final public void ModuleTemplateInstance() throws ParseException {
          String s = getToken(1).image;
          s = s.substring(1,s.length()-1); // Remove the "quotes"
        currInst.setModuleTemplateInstance(currInst.getModuleTemplate().getInstance(s));
          ModuleInstance modInst = xdlDesign.addInstanceToModuleInstances(currInst, currModuleInstanceName);
          //System.out.println(currInst.getModuleTemplateInstance().getName() +" =?= " + currInst.getModuleTemplate().getAnchor().getName());
          if(currInst.getModuleTemplateInstance().equals(currInst.getModuleTemplate().getAnchor()))
          {
            modInst.setAnchor(currInst);
          }
    jj_consume_token(QUOTED_STRING);
  }

// <inst_placement>  ::= <inst_placed>
//                     | <inst_unplaced>
//                     ;
  final public void InstancePlacement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLACED:
      InstancePlaced();
      break;
    case UNPLACED:
      InstanceUnplaced();
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<inst_placed>     ::= "placed" <tile_name> <primitive_site> ;
  final public void InstancePlaced() throws ParseException {
    jj_consume_token(PLACED);
    TileName();
    PrimitiveSite();
    jj_consume_token(COMMA);
  }

//<tile_name>       ::= <string> ;
  final public void TileName() throws ParseException {
          Tile tile = dev.getTile(getToken(1).image);
          if(tile.getType()==null){
          System.out.println("Invalid tile type:" + getToken(1).image);
          System.exit(1);
          }
    jj_consume_token(UNQUOTED_STRING);
  }

//<primitive_site>  ::= <string> ;
  final public void PrimitiveSite() throws ParseException {
          currInst.place(dev.getPrimitiveSite(getToken(1).image));
    jj_consume_token(UNQUOTED_STRING);
  }

// <inst_unplaced>   ::= "unplaced"
//                     | "unplaced" "bonded"
//                     | "unplaced" "unbonded"
//                     ;
  final public void InstanceUnplaced() throws ParseException {
          String next = getToken(2).image;

          if(next.equals("bonded")){
            currInst.setBonded(true);
          }
          else if(next.equals("unbonded")){
            currInst.setBonded(false);
          }
          else{
            currInst.setBonded(null);
          }
    jj_consume_token(UNPLACED);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BONDED:
    case UNBONDED:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BONDED:
        jj_consume_token(BONDED);
        break;
      case UNBONDED:
        jj_consume_token(UNBONDED);
        break;
      default:
        jj_la1[9] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    jj_consume_token(COMMA);
  }

//<module_cfg>        ::= "cfg" <DOUBLEQUOTE><cfg_string><DOUBLEQUOTE> ;
  final public void ModuleConfiguration() throws ParseException {
          inModuleCfg = true;
    jj_consume_token(CFG);
    jj_consume_token(DOUBLEQUOTE);
    ConfigurationString();
    jj_consume_token(DOUBLEQUOTE);
  }

//<inst_cfg>        ::= "cfg" <DOUBLEQUOTE><cfg_string><DOUBLEQUOTE> ;
  final public void InstanceConfiguration() throws ParseException {
    jj_consume_token(CFG);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOUBLEQUOTE:
      jj_consume_token(DOUBLEQUOTE);
      ConfigurationString();
      jj_consume_token(DOUBLEQUOTE);
      break;
    case QUOTED_STRING:
      alternateBelConfiguration();
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// This has to be used because XDL syntax isn't very good and I am not a JavaCC master.
// One line cfg strings will fall to this method
  final public void alternateBelConfiguration() throws ParseException {
        String cfgString = getToken(1).image;
        String[] attributeStrings = cfgString.split("\u005c\u005cs+");
        for(String s : attributeStrings){
          if(!s.equals("\u005c"")){
                if(s.charAt(0) == '\u005c"'){
          processAttribute(s.substring(1));
        }
        else if(s.charAt(s.length()-1) == '\u005c"'){
          processAttribute(s.substring(0,s.length()-1));
        }
        else{
          processAttribute(s);
        }
          }
        }
    jj_consume_token(QUOTED_STRING);
  }

// <cfg_string>      ::= <bel_cfg>
//                     | <cfg_string > <bel_cfg>
//                     ;
  final public void ConfigurationString() throws ParseException {
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UNQUOTED_STRING:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_4;
      }
      BelConfiguration();
    }
  }

//<bel_cfg>         ::= <physical_name> ":" <logical_name> ":" <cfg_val> ;
  final public void BelConfiguration() throws ParseException {
          String attribute = getToken(1).image;
          int break1, break2;
          Boolean backslash = false;
          break1 = attribute.indexOf(':');
          break2 = attribute.indexOf(':',break1+1);
          String phy_name = pool.getUnique(attribute.substring(0,break1));
          String log_name = pool.getUnique(attribute.substring(break1+1,break2));
          String cfg_value = pool.getUnique(attribute.substring(break2+1,attribute.length()));

          try{
                    if(phy_name.equals("_INST_PROP")){ // Look out, this case is nasty
                              char curr = jj_input_stream.readChar();
                while(!(curr == '\u005cn' || curr == '\u005cr' || (curr == ' ' && !backslash))){
                //System.out.println("curr=" + curr);
                                        if(curr == '\u005c\u005c'){
                                                backslash = true;
                                        }
                                        else{
                                                  backslash = false;
                                        }
                                        cfg_value += curr;
                                        curr = jj_input_stream.readChar();
                              }
                    }
          }
          catch (java.io.IOException e){
                    System.out.println("IOException during parsing.");
                    System.exit(1);
          }

          if(inDesignCfg){ // If this is the design configuration
                    xdlDesign.addAttribute(phy_name,log_name,cfg_value);
          }
          else if(currModule != null && inModuleCfg){
                    currModule.addAttribute(phy_name,log_name,cfg_value);
          }
          else{ // This is an instance configuration
                    currInst.addAttribute(phy_name,log_name,cfg_value);
          }
    jj_consume_token(UNQUOTED_STRING);
  }

//<inst_pin_name>   ::= <string> ;
  final public void InstancePinName() throws ParseException {
        currPin.setPinName(pool.getUnique(getToken(1).image));
        if(currModule != null)
        {
          modPinMap.put(currPin.getInstanceName()+currPin.getName(), currPin);
        }
    jj_consume_token(UNQUOTED_STRING);
  }

// <net>             ::= "net" <net_name> <net_type> <net_stmts> ";"
//                     | "net" <net_name> <net_type> ";"
//                     | "net" <net_name> <net_stmts> ";"
//                     ;
  final public void Net() throws ParseException {
    jj_consume_token(NET);
    NetName();
    if (jj_2_1(2)) {
      NetType();
      jj_consume_token(COMMA);
      NetStatements();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VCC:
      case VDD:
      case GND:
      case WIRE:
      case POWER:
      case GROUND:
        NetType();
        break;
      case COMMA:
        jj_consume_token(COMMA);
        NetStatements();
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(SEMICOLON);
  }

//<net_name>        ::= <string> ;
  final public void NetName() throws ParseException {
          currNet = new Net();
          String s = getToken(1).image;
          s = s.substring(1,s.length()-1); // Remove the "quotes"
        currNet.setName(pool.getUnique(s));

        if(currModule == null){
                    xdlDesign.addNet(currNet);
          }
          else{
                    currModule.addNet(currNet);
          }
    jj_consume_token(QUOTED_STRING);
  }

// <net_type>        ::= "vcc"           #power
//                     | "vdd"           # power
//                     | "power"         # power
//                     | "gnd"           # ground
//                     | "ground"        # ground
//                     | "wire"          # wire (optional)
//                     ;
  final public void NetType() throws ParseException {
          String type = getToken(1).image;
          if(type.equals("") || type == null || type.equalsIgnoreCase("wire")){
            currNet.setType(NetType.WIRE);
          }
          else if(type.equalsIgnoreCase("vcc") || type.equalsIgnoreCase("vdd") || type.equalsIgnoreCase("power")){
                  currNet.setType(NetType.VCC);
          }
          else if(type.equalsIgnoreCase("gnd") || type.equalsIgnoreCase("ground")){
            currNet.setType(NetType.GND);
          }
          else{
                  currNet.setType(NetType.UNKNOWN);
          }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VCC:
      jj_consume_token(VCC);
      break;
    case VDD:
      jj_consume_token(VDD);
      break;
    case POWER:
      jj_consume_token(POWER);
      break;
    case GND:
      jj_consume_token(GND);
      break;
    case GROUND:
      jj_consume_token(GROUND);
      break;
    case WIRE:
      jj_consume_token(WIRE);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// <net_stmts>       ::= <net_stmt>
//                     | <net_stmts> <net_stmt>
//                     ;
  final public void NetStatements() throws ParseException {
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CFG:
      case PIP:
      case LOAD:
      case INPIN:
      case OUTPIN:
      case DRIVER:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_5;
      }
      NetStatement();
      jj_consume_token(COMMA);
    }
  }

// <net_stmt>        ::= <COMMA> <net_inpin>
//                     | <COMMA> <net_outpin>
//                     | <COMMA> <net_pip>
//                     ;
  final public void NetStatement() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOAD:
    case INPIN:
      NetInPin();
      break;
    case OUTPIN:
    case DRIVER:
      NetOutPin();
      break;
    case PIP:
      NetPIP();
      break;
    case CFG:
      NetCfg();
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

// <net_inpin>       ::= "inpin" <inst_name> <inst_pin_name>
//                     | "load"  <inst_name> <inst_pin_name>
//                     ;
  final public void NetInPin() throws ParseException {
          currPin = new Pin();
          currPin.setIsOutputPin(false);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INPIN:
      jj_consume_token(INPIN);
      break;
    case LOAD:
      jj_consume_token(LOAD);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    InstanceName_Net();
    InstancePinName();
  }

// <net_outpin>      ::="outpin" <inst_name> <inst_pin_name>
//                     | "driver" <inst_name> <inst_pin_name>
//                     ;
  final public void NetOutPin() throws ParseException {
          currPin = new Pin();
          currPin.setIsOutputPin(true);
          if(currNet.getSource() != null){
                    System.out.println("This net has 2 sources, this shouldn't be valid: " + currNet);
          }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OUTPIN:
      jj_consume_token(OUTPIN);
      break;
    case DRIVER:
      jj_consume_token(DRIVER);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    InstanceName_Net();
    InstancePinName();
  }

  final public void InstanceName_Net() throws ParseException {
          String s = getToken(1).image;
          s = s.substring(1,s.length()-1); // Remove the "quotes"
  Instance inst;
  if(currModule == null){
                    inst = xdlDesign.getInstance(s);
  }
  else{
    inst = currModule.getInstance(s);
  }

                                currPin.setInstance(inst);
                                currNet.addPin(currPin);
  inst.addToNetList(currNet);
    jj_consume_token(QUOTED_STRING);
  }

//<net_pip>         ::= "pip" <tile> <wire0> <pip_direction> <wire1> ;
  final public void NetPIP() throws ParseException {
          currPIP = new PIP();
          currNet.getPIPs().add(currPIP);
    jj_consume_token(PIP);
    Tile();
    Wire0();
    PIPDirection();
    Wire1();
  }

  final public void NetCfg() throws ParseException {
    jj_consume_token(CFG);
    jj_consume_token(DOUBLEQUOTE);
    NetCfgValue();
    jj_consume_token(DOUBLEQUOTE);
  }

  final public void NetCfgValue() throws ParseException {
          Boolean backslash = false;
          String netCfg = getToken(1).image;
          try{
                    char curr = jj_input_stream.readChar();
                    if(curr == ','){ // Look out, this case is nasty
                              while(!(curr == '\u005cn' || curr == '\u005cr' || (curr == ' ' && !backslash) || curr == '\u005c"')){
                                        if(curr == '\u005c\u005c'){
                                                  backslash = true;
                                        }
                                        else{
                                                  backslash = false;
                                        }
                                        netCfg += curr;
                                        curr = jj_input_stream.readChar();
                              }
                    }
                    if(curr == '\u005c"'){
                              jj_input_stream.backup(1);
                    }
          }
          catch (java.io.IOException e){
                    System.out.println("IOException during parsing.");
          }
                  int break1 = netCfg.indexOf(':');
          int break2 = netCfg.indexOf(':',break1+1);
          String phy_name = pool.getUnique(netCfg.substring(0,break1));
          String log_name = pool.getUnique(netCfg.substring(break1+1,break2));
          String cfg_value = pool.getUnique(netCfg.substring(break2+1,netCfg.length()));
          currNet.addAttribute(phy_name,log_name,cfg_value);
          if(phy_name.equals("_MACRO")){
            ModuleInstance mi = xdlDesign.getModuleInstance(cfg_value);
    currNet.setModuleInstance(mi);
    mi.addNet(currNet);
    Module module = mi.getModule();
    currNet.setModuleTemplate(module);
    currNet.setModuleTemplateNet(module.getNet(currNet.getName().replaceFirst(mi.getName()+"/","")));
  }
    jj_consume_token(UNQUOTED_STRING);
  }

//<tile>            ::= <string> ;
  final public void Tile() throws ParseException {
          Tile tile = dev.getTile(getToken(1).image);
          if(tile.getType()==null){
                    System.out.println("Invalid tile type:" + getToken(1).image);
                    System.exit(1);
          }
          currPIP.setTile(tile);
    jj_consume_token(UNQUOTED_STRING);
  }

//<wire0>           ::= <string> ;
  final public void Wire0() throws ParseException {
          currPIP.setStartWire(we.getWireEnum(getToken(1).image));
    jj_consume_token(UNQUOTED_STRING);
  }

// <pip_direction>   ::= "=="      # Bidirectional, unbuffered,
//                     | "=>"       # Bidirectional, buffered (node0 onto node1)
//                     | "=-"       # Bidirectional, buffered (both directions)
//                     | "->"       # Directional, buffered (node0 onto node1)
//                     ;
  final public void PIPDirection() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PIP0:
      jj_consume_token(PIP0);
      break;
    case PIP1:
      jj_consume_token(PIP1);
      break;
    case PIP2:
      jj_consume_token(PIP2);
      break;
    case PIP3:
      jj_consume_token(PIP3);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//<wire1>           ::= <string> ;
  final public void Wire1() throws ParseException {
          currPIP.setEndWire(we.getWireEnum(getToken(1).image));
    jj_consume_token(UNQUOTED_STRING);
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_3_1() {
    if (jj_3R_6()) return true;
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3R_6() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  /** Generated Token Manager. */
  public DesignParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[20];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x80,0x82200000,0x82200000,0x1000000,0x2200000,0x2200000,0x2000000,0x80000000,0x10000000,0x20000000,0x20000000,0x40,0x0,0x48870080,0x48870000,0x4580000,0x4580000,0x4400000,0x0,0xf000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x40,0x40,0x0,0x40,0x40,0x40,0x0,0x10,0x20,0x20,0x100,0x80,0x0,0x0,0xc,0xc,0x0,0xc,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[1];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public DesignParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public DesignParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new DesignParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public DesignParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new DesignParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public DesignParser(DesignParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(DesignParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 20; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[41];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 20; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 41; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
